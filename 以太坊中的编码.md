## RLP编码

RLP (递归长度前缀)提供了一种适用于任意二进制数据数组的编码，RLP已经成为以太坊中对对象进行序列化的主要编码方式。 RLP的唯一目标就是解决结构体的编码问题；对原子数据类型（比如，字符串，整数型，浮点型）的编码则交给更高层的协议；以太坊中要求数字必须是一个大端字节序的、没有零占位的存储的格式（也就是说，一个整数0和一个空数组是等同的）。

#### RLP编码规则

总体可以概括为: `内容` (单字节) , `前缀+内容` (总长<55) , 或 `前缀+长度+内容` (总长>55)

1. **规则1(内容).** . [0x00, 0x7f] 范围内的 `单个字节` , RLP 编码内容就是字节内容本身。

例子：

- `‘a’ = 0x61`
- 整数  `15('\x0f') = 0x0f`

1. **规则2(前缀+内容).** . 0-55字节长度的字符串，RLP编码是 `前缀（0x80+len(字符串)）+字符串内容`

例子：

- abc编码结果是0x83 0x61 0x62 0x63，其中0x83=0x80+len("abc")。
- 整数 1024('\x04\00') = [0x82, 0x04, 0x00]
- 空字符串 "" = 0x80
- 字符串  `"dog" = [0x83, 'd', 'o', 'g' ]`

1. **规则3(前缀+长度+内容)** . >55字节长度字符串, RLP编码是 `前缀（0xb7＋len(len(字符串)))+len(字符串)+字符串内容`

例子:

- 字符串 "Lorem ipsum dolor sit amet, consectetur adipisicing elit" = [0xb8, 0x38, 'L', 'o', 'r', 'e', 'm', ' ', ... , 'e', 'l', 'i', 't']

1. **规则4(前缀+内容).** . 列表的总长度（列表的总长度指的是它包含的项的数量加它包含的各项的长度之和）是0-55字节，它的RLP编码是 `前缀(0xc0+len(列表总))+列表中各元素项的RLP编码` ，前缀取值范围是 `[0xc0, 0xf7]` 。

例子:

- 列表  `["cate","dog"] = [0xc9, 0x84, 'c', 'a', 't', 'e',0x83, 'd', 'o', 'g' ]`

  `0xc9` = 0xc0+ 1+4+1+3 (1:字符串长度的长度, 4:字符串长度, 1:字符串长度的长度,3:字符串长度)

- 列表  `[ [], [[]], [ [], [[]] ] ] = [0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0]`

- **规则5(前缀+长度+内容).** ** ** 列表的总长度大于55字节，它的RLP编码是 `前缀(0xf7+len(len(列表总)))+len(列表总)+列表中各元素项的RLP编码` ，前缀取值范围是 `[0xf8, 0xff]` 。

  例子:

  - 列表 `["The length of this sentence is more than 55 bytes, ", "I know it because I pre-designed it"] = [0xf8 0x58 0xb3 'T','h','e',...`

    0xf8=0xf7+1 (1:列表总长度的长度)

    0x58=0x56+1+1 (0x56:列表总长度 1+1: 2个字符串长度的长度)

    0xb3=0x80+0x33 (33: 字符串长度)

综合编码的例子:

```
["abc",["The length of this sentence is more than 55 bytes, ", "I know it because I pre-designed it"]]
= [0xf8 0x5e 0x83 0x61 98 99 248 88 179 84 104 101 32 108 101 110 103 116 104 32 111 102 32 116 104 105 115 32 115 101 110 116 101 110 99 101 32 105 115 32 109 111 114 101 32 116 104 97 110 32 53 53 32 98 121 116 101 115 44 32 163 73 32 107 110 111 119 32 105 116 32 98 101 99 97 117 115 101 32 73 32 112 114 101 45 100 101 115 105 103 110 101 100 32 105 116]
```

0xf8=0xf7+1 (1:列表总长度的长度)

0x5e=90 + 1 +2 +1 (90:字符串总长度 1:第一个字符串前缀长度 2: 第二个字符串前缀+长度 1: 第三个字符串前缀)

#### RLP解码规则

1. 如果f∈ [0,128),　那么它是一个字节本身。

2.　如果f∈[128,184)，那么它是一个长度不超过55的byte数组，数组的长度为  `l=f-128`

3.　如果f∈[184,192)，那么它是一个长度超过55的数组，长度本身的编码长度 `ll=f-183` ,然后从第二个字节开始读取长度为ll的bytes，按照BigEndian编码成整数l，l即为数组的长度。

4.　如果f∈(192,247]，那么它是一个编码后总长度不超过55的列表，列表长度为 `l=f-192` 。递归使用规则1~4进行解码。

5.　如果f∈(247,256]，那么它是编码后长度大于55的列表，其长度本身的编码长度 `ll=f-247` ,然后从第二个字节读取长度为ll的bytes,按BigEndian编码成整数l，l即为子列表长度。然后递归根据解码规则进行解码。

#### RLP在以太坊中的使用

以构成交易树/状态树为例：

```go
func DeriveSha(list DerivableList) common.Hash {
	keybuf := new(bytes.Buffer)
	trie := new(trie.Trie)
	for i := 0; i < list.Len(); i++ {
		keybuf.Reset()
        //编码序号
		rlp.Encode(keybuf, uint(i))
        //编码list[i]并存入mpt树中
		trie.Update(keybuf.Bytes(), list.GetRlp(i))
	}
	return trie.Hash()
}
```

构成最底层mpt树的时候，将 序号rlp编码，交易内容的rlp编码 构成一个键值对 放入mpt树中存储

#### MPT中的编码

在以太坊协议中，不管是地址还是hash，都是一个16进制串，如"0x5b3edbcf7d0a97e95e57a4554a29ea66601b71ad"，数据最小的表示单位为一位16进制，如1、a等，但在编程实现中，数据的最小表示单位往往是byte（8bit，2位16进制数），这样在用byte来表示一串奇数长度的16进制串时会出现问题，如"5b3"和"5b30"，直接转成byte都是5b30。还有一种简单直观的转换方式，"5b3"->"050b03"，这种方式虽然简单，但是数据量会翻倍，不利于大量hash的计算，同时也会增加tree的大小，降低同步性能。Hex-Prefix Encoding能解决这些问题。

###### hex编码

用于树路径中，是将数据 key 进行半字节拆解而成。即依次将 key[0],key[1],…,key[n] 分别进行半字节拆分成两个数，再依次存放在长度为 len(key)+1 的数组中。 并在数组末尾写入终止符 `16`。算法如下：

```go
// trie/encoding.go:65
func keybytesToHex(str []byte) []byte {
	l := len(str)*2 + 1
	var nibbles = make([]byte, l)
	for i, b := range str {
		nibbles[i*2] = b / 16
		nibbles[i*2+1] = b % 16
	}
	nibbles[l-1] = 16
	return nibbles
}
```



例如：字符串 “romane” 的 bytes 是 `[114 111 109 97 110 101]`，在 HEX 编码时将其依次处理：

| i    | key[i] | key[i]二进制 | nibbles[i*2]=高四位 | nibbles[i*2+1]=低四位 |
| :--- | :----- | :----------- | :------------------ | :-------------------- |
| 0    | 114    | 011100102    | 01112= 7            | 00102= 2              |
| 1    | 111    | 011011112    | 01102=6             | 11112=15              |
| 2    | 109    | 011011012    | 01102=6             | 11012=13              |
| 3    | 97     | 011000012    | 01102=6             | 00012=1               |
| 4    | 110    | 011011102    | 01102=6             | 11102=14              |
| 5    | 101    | 011001012    | 01102=6             | 01012=5               |

###### HP(Hex-Prefix) 编码

输入 key 结尾为 0x10，则去掉这个终止符。

key 之前补一个二进制flag四元组(Nibble)， 这个四元组第 0 位区分奇偶信息，第 1 位区分节点类型。

如果输入 key 的长度是偶数，则再添加一个四元组 0x0 在 flag 四元组后。

将原来的 key 内容压缩，将分离的两个 hex(Nibble) 以高四位低四位进行合并成一个byte。

 