### 线程之间的通信inproc

**一、为什么要线程通信？**

1.多个线程并发执行时, 在默认情况下CPU是**随机切换线程**的，当我们需要多个线程来**共同完成**一件任务，

　　 并且我们希望他们**有规律**的执行, 那么多线程之间需要一些**协调通信**，以此来帮我们达到**多线程共同操作一份数据**。

2.当然如果我们没有使用线程通信来使用多线程共同操作同一份数据的话，虽然可以实现，

　　但是在很大程度会造成多线程之间对同一共享变量的争夺，那样的话势必为造成很多错误和损失！

3.所以，我们才引出了线程之间的通信，`多线程之间的通信能够避免对同一共享变量的争夺。` 

**二、什么是线程通信？** 

多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。

就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺

于是我们引出了等待唤醒机制：（wait()、notify()）

就是在一个线程进行了规定操作后，就进入等待状态（wait）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（notify）；

###### （1）WAIT()方法：

在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，**导致当前线程等待**。

线程调用wait()方法，**释放**它对锁的拥有权，然后**等待另外的线程来通知它**（通知的方式是notify()或者notifyAll()方法），这样它才能重新获得锁的拥有权和恢复执行。

要确保调用wait()方法的时候**拥有锁**，即，wait()方法的调用必须放在**synchronized**方法或**synchronized**块中。

###### **（2）notif()方法：**

notify()方法会唤醒一个等待当前对象的锁的线程。唤醒在此对象监视器上等待的单个线程。

###### （3）notifAll()方法：

notifyAll（）方法会唤醒在此对象监视器上等待的所有线程。
 如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait方法中的一个）

notify()方法应该是被拥有对象的锁的线程所调用。



一般而言,在一个应用程序中（即进程），一个线程往往不是孤立存在的，常常需要和其它线程通信，以执行特定的任务。如主线程和次线程，次线程与次线程，工作线程和用户界面线程等。这样,线程与线程间必定有一个信息传递的渠道。这种线程间的通信不但是难以避免的，而且在多线程编程中也是复杂和频繁的。




### **进程间通信**ipc

又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:
 1、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)
 2、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).

- [管道( pipe )]()：管道是一种[半双工的通信方式]()，数据只能单向流动，而且[只能在具有亲缘关系的进程间使用]()。进程的亲缘关系通常是指父子进程关系。
- [有名管道 (named pipe) ]()： 有名管道也是半双工的通信方式，但是它[允许无亲缘关系进程间的通信]()。
- [信号量( semophore )]() ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。[不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源]()。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- [消息队列( message queue ) ]()： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列[克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点]()。
- [信号 ( signal ) ]()： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
- [共享内存( shared memory )] ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是[最快的 IPC 方式]()，它是针对其他进程间通信方式运行效率低而专门设计的。[它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信]()。
- [套接字( socket ) ]()： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。



### HTTP（）



### WebSocket(ws)

**WebSocket**是一种在单个[TCP](https://baike.baidu.com/item/TCP)连接上进行[全双工](https://baike.baidu.com/item/全双工)通信的协议。WebSocket通信协议于2011年被[IETF](https://baike.baidu.com/item/IETF)定为标准RFC 6455，并由RFC7936补充规范。WebSocket [API](https://baike.baidu.com/item/API)也被[W3C](https://baike.baidu.com/item/W3C)定为标准。

WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

优点：

- 较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10[字节](https://baike.baidu.com/item/字节)（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的[掩码](https://baike.baidu.com/item/掩码)。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。
- 更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。
- 保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。
- 更好的二进制支持。Websocket定义了[二进制](https://baike.baidu.com/item/二进制)帧，相对HTTP，可以更轻松地处理二进制内容。
- 可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持[压缩](https://baike.baidu.com/item/压缩)等。
- 更好的压缩效果。相对于[HTTP压缩](https://baike.baidu.com/item/HTTP压缩)，Websocket在适当的扩展支持下，可以沿用之前内容的[上下文](https://baike.baidu.com/item/上下文)，在传递类似的数据时，可以显著地提高压缩率。

WebSocket 是独立的、创建在 TCP 上的协议。

Websocket 通过[HTTP](https://baike.baidu.com/item/HTTP)/1.1 协议的101状态码进行握手。